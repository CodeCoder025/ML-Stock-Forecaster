def weightsAnalysis(metricsList, RMSEScores = None, linearRegWeights = None, randomForestWeights = None, GBMWeights = None):
    featureGroupedWeights = []
    weightsListsDict = {"Linear Regression Model" :linearRegWeights,"Random Forest Model": randomForestWeights, "Gradient Boosting Machine":GBMWeights}
    weightsListsDict = {key:weightsListsDict.get(key) for key, value in weightsListsDict.items() if value is not None}
    weightsListsDictFresh = {}
    for key, value in weightsListsDict.items():
        try:
            weightsListsDictFresh[key] = value.tolist()
        except AttributeError:
            weightsListsDictFresh[key] = value #i wont have any idea whether it would be a list, or an array being passed through this function.
    returnDict = {}
    returnDict["Model"] = list(weightsListsDictFresh.keys())
    if RMSEScores is not None:
        returnDict["RMSE Score"] = RMSEScores
    for i in range(len(list(weightsListsDictFresh.values())[0])):
        weightsByMetric = []
        for weightsList in weightsListsDictFresh.values():
            weightsByMetric.append(weightsList[i])
        returnDict[metricsList[i]] = weightsByMetric
    return returnDict

weightsDict = weightsAnalysis(trainingData.drop(columns=["%changeTomorrow"]).columns.to_list(),
                RMSEScores= [linearRegModelScore, randomForestScore],
                linearRegWeights = linearRegModelCoefs, 
                randomForestWeights = randomForestWeights)

#Idea:
#Can try to optimize accuracy of predictions by creating my own ML model which randomly swaps weights generated by the two models, then computes predictions to see if loss function is minimized. Can also create a regressor which takes the average of weights created by these models.
