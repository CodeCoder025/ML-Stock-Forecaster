import pandas as pd
import numpy as np
import yfinance as yf
from sklearn import preprocessing
#IMPORTANT REMINDER: I cannot have the model predict today's price change using today's volume --- i can only use the data which I had before today. Prices to predict are close prices, not high,low, or open!
#Columns which has a name starting with "!" are columns which CANNOT be given to the model in predicting prices.
#Idea: Can also one-hot encode for crossovers
#An important concept to note throughout the course of this project is that the model is not able to cross-compare between metrics, thus any possible correlation must be spoon-fed. It is also worth noting that the model cannot put things into context, metrics have to be put into a percentage with little undesirable drift over time. (e.g. if i feed it OHLC< predictions will take after more recent price action, because open, high, low, and close prices now are more like those in 2025 than those in 1995.
#To avoid logical errors, I will call .dropna() as soon as NaN values are present
#Remember not to feed non-contextual data into ML model (e.g. never feed raw OHLC data or raw SMA data, but feed RELATIVE data --- not 38.50 price data but 3% up from last week pricce data. Not 5028000 shares traded on Friday type of volume data, but 14% higher volume as compared to monthly average type of data.
#^^^ The above is obvious because more recent data will have higher everything --- higher price, higher volume, higher volatility etc. Thus make everything in relative percentages so that model will not be affected by magnitude drifts over time.

def handleOHLC(ticker,startDate,endDate):
    startDate = startDate
    endDate = endDate
    ticker = ticker
    OHLC_data = yf.download(ticker, start = startDate, end = endDate).reset_index()
    SnP500 = yf.download("^GSPC",start = startDate, end = endDate, interval = "1d").reset_index()
    OHLC_data.columns = OHLC_data.columns.get_level_values(0)
    SnP500.columns = SnP500.columns.get_level_values(0)
    OHLC_data["%changeToday"] = (OHLC_data["Close"] - OHLC_data["Open"])/OHLC_data["Open"]
    OHLC_data["high%AboveClose"] = (OHLC_data["High"] - OHLC_data["Close"])/OHLC_data["Close"]
    OHLC_data["high%AboveOpen"] = (OHLC_data["High"]-OHLC_data["Open"])/OHLC_data["Open"]
    OHLC_data["low%BelowClose"] = (OHLC_data["Close"]-OHLC_data["Low"])/OHLC_data["Close"]
    OHLC_data["low%BelowOpen"] = (OHLC_data["Open"]-OHLC_data["Low"])/OHLC_data["Open"]
    OHLC_data["Spread"] = (OHLC_data["High"]-OHLC_data["Low"])/(OHLC_data["Open"]+OHLC_data["Close"])
    OHLC_data["volumeToSpreadRatio"] = OHLC_data["Volume"]/OHLC_data["Spread"] #Sniffs insitutional trading if high vol to spread
    SnP500["SnP_%Spread"] = abs(SnP500["High"]-SnP500["Low"])/((SnP500["Open"]+SnP500["Close"])/2)
    SnP500["SnP_%Change"] = (SnP500["Close"]-SnP500["Open"])/SnP500["Open"]
    SnP500 = SnP500.rename(columns = {"Open" : "SnP_Open",
                                        "Close": "SnP_Close",
                                        "High": "SnP_High",
                                        "Low":"SnP_Low",
                                        "Volume":"SnP_Volume"})
    GoldFutures = yf.download("GC=F", start = startDate, end = endDate).reset_index()
    GoldFutures.columns = GoldFutures.columns.get_level_values(0)
    GoldFutures["Gold_%Spread"] = abs(GoldFutures["High"]-GoldFutures["Low"])/((GoldFutures["Open"]+GoldFutures["Close"])/2)
    GoldFutures["Gold_%Change"] = (GoldFutures["Close"]-GoldFutures["Open"])/GoldFutures["Open"]
    GoldFutures = GoldFutures.rename(columns = {"Open":"GoldFutures_Open",
                                                "Close":"GoldFutures_Close",
                                                "High":"GoldFutures_High",
                                                "Low":"GoldFutures_Low",
                                                "Volume":"GoldFutures_Volume"})
    OHLC_data = pd.merge(OHLC_data, SnP500, on = "Date", how = "inner")
    OHLC_data = pd.merge(OHLC_data, GoldFutures, on = "Date", how = "inner")
    OHLC_data["stockToSnP_Spread"] = OHLC_data["Spread"]/OHLC_data["SnP_%Spread"]
    OHLC_data["stockToGold_Spread"] = OHLC_data["Spread"]/OHLC_data["Gold_%Spread"]
    OHLC_data["stockToGold_OutperformanceMultiplier"] = (OHLC_data["%changeToday"]-OHLC_data["Gold_%Change"])/OHLC_data["%changeToday"]
    OHLC_data["stockToSnP_OutperformanceMultiplier"] = (OHLC_data["%changeToday"]-OHLC_data["SnP_%Change"])/OHLC_data["%changeToday"]
    OHLC_data["!tomorrowPrice"] = OHLC_data["Close"].shift(-1)
    OHLC_data.dropna(inplace = True)
    OHLC_data["%changeTomorrow"] = (OHLC_data["!tomorrowPrice"]-OHLC_data["Close"])/OHLC_data["Close"]#This is the target variable
    OHLC_data.insert(0,"StockName",[ticker for i in range(len(OHLC_data))])
    return OHLC_data

def xDMA_column(columnName,x, OHLC_data): #it is important to remember that the result returned by this is the RATIO of the metric type to the moving average. It returns a ratio, not a raw/absolute value
    newColumnName = "%sTo%sDay_SMA"%(columnName,x)
    OHLC_data[newColumnName] = None
    newColumnIndex = OHLC_data.columns.get_loc(newColumnName)
    for index, row in OHLC_data.iterrows():
        if index < x:
            continue
        else:
            OHLC_data[newColumnName] = OHLC_data[columnName]/OHLC_data[columnName].rolling(x).mean()
    

def checkForCrossover(metric1, metric2, rowIndex, OHLC_data,metric1Multiplier = None, metric2Multiplier = None): #OOH i just realised that metricMultipliers will be necessary since most columns in the dataframe are ratio or percentage-based
    #function will return 1 if metric1 crosses over metric 2, -1 if 1 falls below 2 (ie 2 over 1), 0 if neither.
    if metric1Multiplier:
        metric1MultiplierPrev = OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric1Multiplier)]
        metric1MultiplierNow = OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1Multiplier)]
    else:
        metric1MultiplierPrev = 1
        metric1MultiplierNow = 1
    if metric2Multiplier:
        metric2MultiplierPrev = OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric2Multiplier)]
        metric2MultiplierNow = OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric2Multiplier)]
    else:
        metric2MultiplierPrev = 1
        metric2MultiplierNow = 1
    if rowIndex == 0:
        return
    else:
        initialState = 3 #As an indicator of which is initially higher. 3 is if 1 is initially higher (slightly confusing but this is so that i can reduce the number of if statements later on
        if OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierPrev < OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric2)]*metric2MultiplierPrev:
            initialState = 2
        if OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierNow < OHLC_data.iloc[rowIndex,OHLC_data.columns.get_loc(metric2)]*metric2MultiplierNow:
            return (2-initialState)
        elif OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierNow > OHLC_data.iloc[rowIndex,OHLC_data.columns.get_loc(metric2)]*metric2MultiplierNow:
            return (3-initialState)    #ngl i really like this maths
        else:
            return 0

def configureDateData(OHLC_data):
    OHLC_data["Date"] = pd.to_datetime(OHLC_data["Date"])
    OHLC_data["Month"] = OHLC_data["Date"].dt.month
    OHLC_data["DayOfMonth"] = OHLC_data["Date"].dt.day
    OHLC_data["Day"] = OHLC_data["Date"].dt.dayofweek

def getRollingBetas(OHLC_data, daysToRoll): #Problem with this is that a LOT of data will be sacrificed when .dropna() is called
    columnNameRn = "%sDay_RollingBeta"%daysToRoll
    OHLC_data[columnNameRn] = None
    for i in range(len(OHLC_data)):
        if i < daysToRoll:
            continue
        else:
            covarianceSum = 0
            varianceSum = 0
            for j in range(daysToRoll):
                covarianceSum += OHLC_data.iloc[i-j, OHLC_data.columns.get_loc("%changeToday")]*OHLC_data.iloc[i-j, OHLC_data.columns.get_loc("SnP_%Change")]
                varianceSum += (OHLC_data.iloc[i-j, OHLC_data.columns.get_loc("SnP_%Change")])**2
            OHLC_data.iloc[i, OHLC_data.columns.get_loc(columnNameRn)] = covarianceSum/varianceSum
    OHLC_data.dropna(inplace = True)

def getBetaRatios(OHLC_data): #Find ratio of current beta to rolling beta
  betaColumnIndices = [OHLC_data.columns.get_loc(i)
                       for i in OHLC_data.columns.to_list()
                       if i.endswith("Day_RollingBeta")]
  betaDayDenominator = [int(OHLC_data.columns[i].split("Day_")[0])
                        for i in betaColumnIndices]
  newColumnNameList = ["betaTo%sDayRollingBeta"%i
                       for i in betaDayDenominator]
  for i in range(len(newColumnNameList)):
    OHLC_data[newColumnNameList[i]] = OHLC_data["beta_today"]/OHLC_data[OHLC_data.columns[betaColumnIndices[i]]]

def blindFeatureEngineering(n_iter):
  pass

def implementIndicators(OHLC_data):
    for j in range(3,5):
      xDMA_column("Volume",j**2,OHLC_data)
      xDMA_column("Close",j**2,OHLC_data)
      xDMA_column("SnP_Close",j**2,OHLC_data)
    OHLC_data.dropna(inplace=True)
    OHLC_data=OHLC_data.reset_index()
    OHLC_data.drop(columns=["index"], inplace=True)
    configureDateData(OHLC_data)

    for j in range(3,5):
      OHLC_data["Price-%sD_crossover"%j**2] = [checkForCrossover("Close","CloseTo%sDay_SMA"%j**2,i, OHLC_data,metric2Multiplier = "Close") for i in range(len(OHLC_data))]
      OHLC_data["SnP-%sD_crossover"%j**2] = [checkForCrossover("SnP_Close","SnP_CloseTo%sDay_SMA"%j**2,i,OHLC_data, metric2Multiplier = "SnP_Close") for i in range(len(OHLC_data))]

    OHLC_data.dropna(inplace=True)
    getRollingBetas(OHLC_data, 252)
    getRollingBetas(OHLC_data, 100)
    OHLC_data["beta_today"] = OHLC_data["%changeToday"]/OHLC_data["SnP_%Change"] #Can try comparing beta of stock to beta of gold
    getBetaRatios(OHLC_data)
    encoder = preprocessing.OneHotEncoder()
    categoricalFeatures = ["Month","Day","DayOfMonth"]
    for feature in categoricalFeatures:
      encoder.fit(OHLC_data[[feature]])
      oneHotOrder = encoder.categories_
      oneHotOrder = ["%s_%s"%(feature, i) for i in oneHotOrder[0]]
      oneHotDF = pd.DataFrame(encoder.transform(OHLC_data[[feature]]).toarray(), columns = oneHotOrder)
      OHLC_data = OHLC_data.reset_index()
      OHLC_data.drop(columns=["index"],inplace=True)
      OHLC_data = pd.merge(OHLC_data, oneHotDF, left_index = True, right_index = True)

    trainingData = OHLC_data.drop(columns = ["Date","StockName","Day","GoldFutures_High","GoldFutures_Low","GoldFutures_Open","GoldFutures_Close","GoldFutures_Volume","DayOfMonth","Close","High","Low","Month","Open","Volume","SnP_Close","SnP_Open","SnP_Volume","SnP_High","SnP_Low","!tomorrowPrice"])
    return trainingData


trainingData = implementIndicators(handleOHLC("KO","2010-01-01","2015-01-01"))

    trainingData = OHLC_data.drop(columns = ["Date","StockName","Day","GoldFutures_High","GoldFutures_Low","GoldFutures_Open","GoldFutures_Close","GoldFutures_Volume","DayOfMonth","Close","High","Low","Month","Open","Volume","SnP_Close","SnP_Open","SnP_Volume","SnP_High","SnP_Low","!tomorrowPrice"])
    return trainingData


trainingData = implementIndicators(handleOHLC("KO","2010-01-01","2015-01-01"))
