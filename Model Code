import pandas as pd
import numpy as np
import yfinance as yf
#IMPORTANT REMINDER: I cannot have the model predict today's price change using today's volume --- i can only use the data which I had before today. Prices to predict are close prices, not high,low, or open!
#Columns which has a name starting with "!" are columns which CANNOT be given to the model in predicting prices.
#Idea: Can also one-hot encode for crossovers
#An important concept to note throughout the course of this project is that the model is not able to cross-compare between metrics, thus any possible correlation must be spoon-fed. It is also worth noting that the model cannot put things into context, metrics have to be put into a percentage with little undesirable drift over time. (e.g. if i feed it OHLC< predictions will take after more recent price action, because open, high, low, and close prices now are more like those in 2025 than those in 1995.
#To avoid logical errors, I will call .dropna() as soon as NaN values are present
#Remember not to feed non-contextual data into ML model (e.g. never feed raw OHLC data or raw SMA data, but feed RELATIVE data --- not 38.50 price data but 3% up from last week pricce data. Not 5028000 shares traded on Friday type of volume data, but 14% higher volume as compared to monthly average type of data.
#^^^ The above is obvious because more recent data will have higher everything --- higher price, higher volume, higher volatility etc. Thus make everything in relative percentages so that model will not be affected by magnitude drifts over time.
startDate = "2020-01-01"
endDate = "2023-01-01"
ticker = "NVDA"
OHLC_data = yf.download(ticker, start = startDate, end = endDate).reset_index()
Emini500 = yf.download("ES=F",start = startDate, end = endDate, interval = "1d").reset_index()
OHLC_data.columns = OHLC_data.columns.get_level_values(0)
Emini500.columns = Emini500.columns.get_level_values(0)
Emini500["Emini_%Spread"] = abs(Emini500["High"]-Emini500["Low"])/((Emini500["Open"]+Emini500["Close"])/2)
Emini500["Emini_%Change"] = (Emini500["Close"]-Emini500["Open"])/Emini500["Open"]
Emini500 = Emini500.rename(columns = {"Open" : "Emini_Open",
                                      "Close": "Emini_Close",
                                      "High": "Emini_High",
                                      "Low":"Emini_Low",
                                      "Volume":"Emini_Volume"})
OHLC_data = pd.merge(OHLC_data, Emini500, on = "Date", how = "inner")
OHLC_data["!tomorrowPrice"] = OHLC_data["Close"].shift(-1)
OHLC_data.dropna(inplace = True)
OHLC_data["%changeTomorrow"] = (OHLC_data["!tomorrowPrice"]-OHLC_data["Close"])/OHLC_data["Close"] #This is the target variable

def xDMA_column(columnName,x): #it is important to remember that the result returned by this is the RATIO of the metric type to the moving average. It returns a ratio, not a raw/absolute value
    newColumnName = "%sTo%sDay_SMA"%(columnName,x)
    OHLC_data[newColumnName] = None
    newColumnIndex = OHLC_data.columns.get_loc(newColumnName)
    for index, row in OHLC_data.iterrows():
        if index < x:
            continue
        else:
            cumSum = 0
            for i in range(0,x):
                cumSum += OHLC_data.iloc[index-i, OHLC_data.columns.get_loc(columnName)]
            MA = cumSum/x
            OHLC_data.iloc[index,newColumnIndex] = row[columnName]/MA
            
def checkForCrossover(metric1, metric2, rowIndex, metric1Multiplier = None, metric2Multiplier = None): #OOH i just realised that metricMultipliers will be necessary since most columns in the dataframe are ratio or percentage-based
    #function will return 1 if metric1 crosses over metric 2, -1 if 1 falls below 2 (ie 2 over 1), 0 if neither.
    if metric1Multiplier:
        metric1MultiplierPrev = OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric1Multiplier)]
        metric1MultiplierNow = OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1Multiplier)]
    else:
        metric1MultiplierPrev = 1
        metric1MultiplierNow = 1
    if metric2Multiplier:
        metric2MultiplierPrev = OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric2Multiplier)]
        metric2MultiplierNow = OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric2Multiplier)]
    else:
        metric2MultiplierPrev = 1
        metric2MultiplierNow = 1
    if rowIndex == 0:
        return
    else:
        initialState = 3 #As an indicator of which is initially higher. 3 is if 1 is initially higher (slightly confusing but this is so that i can reduce the number of if statements later on
        if OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierPrev < OHLC_data.iloc[rowIndex-1, OHLC_data.columns.get_loc(metric2)]*metric2MultiplierPrev:
            initialState = 2
        if OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierNow < OHLC_data.iloc[rowIndex,OHLC_data.columns.get_loc(metric2)]*metric2MultiplierNow:
            return (2-initialState)
        elif OHLC_data.iloc[rowIndex, OHLC_data.columns.get_loc(metric1)]*metric1MultiplierNow > OHLC_data.iloc[rowIndex,OHLC_data.columns.get_loc(metric2)]*metric2MultiplierNow:
            return (3-initialState)    #ngl i really like this maths
        else:
            return 0

for j in range(3,5):
    xDMA_column("Volume",j**2)
    xDMA_column("Close",j**2)
OHLC_data.dropna(inplace=True)
OHLC_data=OHLC_data.reset_index()
OHLC_data.drop(columns=["index"], inplace=True)

OHLC_data["Price-16D_crossover"] = [checkForCrossover("Close","CloseTo16Day_SMA",i, metric2Multiplier = "Close") for i in range(len(OHLC_data))]
OHLC_data.dropna(inplace=True)
#data for core stock (not E-mini) has yet to be made relative. Make all these relative my comparing and then using percentages (e.g. use price%aboveSMA instead)
